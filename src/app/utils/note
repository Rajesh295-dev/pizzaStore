
import { prisma } from "@/app/utils/connect";
import { NextRequest, NextResponse } from "next/server";
import { v4 as uuidv4 } from "uuid";

const idempotencyKey = uuidv4();

type Inputs = {
  customer: string;
  phone: string;
};

export async function POST(
  request: NextRequest,
  { params }: { params: { orderId: string; inputs: Inputs } }
) {
  try {
    console.log(
      "Received request:",
      request.body ? await request.text() : null
    );
    console.log("Request headers:", request.headers);

    const { orderId, inputs } = params;

    // Validate request parameters
    if (!orderId || !inputs || !inputs.customer || !inputs.phone) {
      console.error("Invalid request parameters:", orderId, inputs);
      return new NextResponse(
        JSON.stringify({ error: "Invalid request parameters" }),
        { status: 400 }
      );
    }

    const { customer, phone } = inputs;
    console.log("Payment endpoint received value", customer, phone);

    // Extract the initial letter from the full name
    const initials = customer
      .split(" ")
      .map((word: string) => word.charAt(0))
      .join("");

    // Remove non-numeric characters from the phone number
    const numericPhone = phone.replace(/[^\d]/g, "");

    // Create the customIntentId by combining initials and phone number
    const customIntentId = `${initials}${numericPhone}`;
    console.log("Custom ID:", customIntentId);

    // Check if the order exists
    const existingOrder = await prisma.order.findUnique({
      where: {
        id: orderId,
      },
    });

    if (existingOrder) {
      // Update the order with the customIntentId
      const updatedOrder = await prisma.order.update({
        where: {
          id: orderId,
        },
        data: { intent_id: customIntentId },
      });

      console.log("Order has been updated!", updatedOrder);

      // Respond with a success message
      return new NextResponse(
        JSON.stringify({ message: "Order has been updated!" }),
        { status: 200 }
      );
    } else {
      console.error("Order not found:", orderId);
      // Respond with an error message
      return new NextResponse(JSON.stringify({ error: "Order not found" }), {
        status: 404,
      });
    }
  } catch (error) {
    console.error("Error processing request:", error);
    // Respond with a generic error message
    return new NextResponse(
      JSON.stringify({ error: "Internal Server Error" }),
      { status: 500 }
    );
  }
}










// const handleCashPay = async () => {
//   try {
//     if (!orderId) {
//       console.error("Order ID is missing");
//       return;
//     }

//     const response = await fetch(
//       `http://localhost:3000/api/cashPayment/${orderId}`,
//       {
//         method: "POST",
//         headers: {
//           "Content-Type": "application/json",
//         },
//         body: JSON.stringify({
//           inputs,
//           method: "cash", // Add the payment method
//         }),
//       }
//     );

//     if (response.ok) {
//       const updatedOrder = await response.json();
//       console.log("This is the cash intent-id update", updatedOrder);
//     } else {
//       console.error("Failed to update order:", response.statusText);
//     }
//   } catch (error) {
//     console.error("Error updating order:", error);
//   }
// };










// pages/api/cloudinary-proxy.js

import { NextApiRequest, NextApiResponse } from "next";
import Cors from "nextjs-cors";

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  await Cors(req, res);
  if (req.method === "POST") {
    try {
      const cloudinaryResponse = await fetch(
        "https://api.cloudinary.com/v1_1/${process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}/image/upload",
        {
          method: "POST", // Use the appropriate HTTP method
          headers: {
            "Content-Type": "multipart/form-data", // Set headers as needed
            // Add any other headers required for Cloudinary
          },
          body: JSON.stringify(req.body), // Forward the request body
        }
      );

      if (!cloudinaryResponse.ok) {
        console.error(
          `Cloudinary response error: HTTP status ${cloudinaryResponse.status}`
        );
        const data = await cloudinaryResponse.json();
        console.error(data); // Log the Cloudinary response for debugging
        res.status(500).json({ error: "Something went wrong" });
        return;
      }

      const data = await cloudinaryResponse.json();
      res.status(cloudinaryResponse.status).json(data);
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: "Something went wrong" });
    }
  } else {
    res.status(405).json({ error: "Method Not Allowed" });
  }
};
















"use client";
import Image from "next/image";
import React, { useEffect, useState } from "react";
import { useCartStore } from "../utils/store";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import Decimal from "decimal.js";
import Delivery from "@/components/Delivery";

const CartPage = () => {
  const { products, totalItems, totalPrice, removeFromCart } = useCartStore();
  const { data: session } = useSession();
  const router = useRouter();

  useEffect(() => {
    useCartStore.persist.rehydrate();
  }, []);

  const handleCheckout = async () => {
    if (!session) {
      router.push("/login");
    } else {
      try {
        const res = await fetch("http://localhost:3000/api/orders", {
          method: "POST",
          headers: { "Content-type": "application/json" },
          body: JSON.stringify({
            price: totalPrice,
            products,
            status: "Not paid!",
            userEmail: session.user.email,
          }),
        });
        const data = await res.json();
        router.push(`pay/${data.id}`);
      } catch (err) {
        console.log(err);
      }
    }
  };

  const [receivingPreference, setReceivingPreference] = useState("");
  // const [instructions, setInstructions] = useState("");

  const handleReceivingPreferenceChange = (
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    setReceivingPreference(event.target.value);
  };

  const [tipPercentage, setTipPercentage] = useState("0");

  const handleTipPercentageChange = (value: string) => {
    setTipPercentage(value);
  };

  const [calculatedTipAmount, setCalculatedTipAmount] = useState(0);

  // Callback to handle the calculated tip amount
  const handleCalculatedTipAmountChange = (value: number) => {
    setCalculatedTipAmount(value);
  };

  // Calculate service cost based on subtotal
  const serviceCost = 0.06 * totalPrice;

  // Set delivery cost based on the selected receiving preference
  let deliveryCost = 0;
  if (receivingPreference === "delivery") {
    deliveryCost = 2.5;
  }
  useEffect(() => {
    console.log("Tip Percentage:", tipPercentage);
    console.log("Add Amount:", totalPrice);
  }, [tipPercentage, totalPrice]);

  const tipMultiplier = parseFloat(tipPercentage) / 100;
  const tipAmount = tipMultiplier * totalPrice;
  const formattedTipAmount = tipAmount.toFixed(2);

  const totalCost = new Decimal(totalPrice)
    .plus(new Decimal(serviceCost))
    .plus(new Decimal(formattedTipAmount))
    .plus(new Decimal(deliveryCost));

  return (
    <div className=" h-[calc(100vh - 6rem)] md:h-[calc(100vh - 9rem)] flex flex-col text-red-500 xl:flex-row overflow-scroll ">
      {/* products container */}
      <div className=" h-1/2 p-4  flex flex-col justify-center  lg:h-full lg:w-2/2 2xl:w-1/2 lg:px-20 xl:px-40 2xl:text-xl 2xl:gap-6 ">
        {products.map((item) => (
          <div className=" flex items-center justify-between   " key={item.id}>
            {" "}
            {item.img && (
              <Image src={item.img} alt="" width={100} height={100} />
            )}
            <div className="flex flex-col ml-3 md:flex-row">
              <div className=" ">
                <h1 className=" uppercase text-sm md:text-xl font-bold">
                  {item.title} x {item.quantity} Items
                </h1>
                <span className="ml-14">{item.optionTitle}</span>
              </div>
              <h2 className="font-bold ml-14">${item.price}</h2>
              <button
                className="cursor-pointer ml-3 bg-green-500 text-white p-2 rounded-md  "
                onClick={() => removeFromCart(item)}
              >
                EmptyCart
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* payment container */}
      <div className=" h-1/2 p-4 bg-fuchsia-50 flex flex-col gap-4 justify-center  lg:h-full lg:w-2/2 2xl:w-1/2 lg:px-20 xl:px-40 2xl:text-xl 2xl:gap-6">
        <div className=" flex flex-col justify-around  ">
          <h2 className="text-2xl font-bold">
            Select Food Receiving Preference
          </h2>
          {/* Cooking Preference Options */}
          <div className="flex flex-col p-4 gap-3">
            <label>
              <input
                type="radio"
                name="normal"
                value="dine-in"
                checked={receivingPreference === "dine-in"}
                onChange={handleReceivingPreferenceChange}
              />
              <span className="ml-2"> Dine-In</span>
            </label>

            <label>
              <input
                type="radio"
                name="pickup"
                value="pickup"
                checked={receivingPreference === "pickup"}
                onChange={handleReceivingPreferenceChange}
              />
              <span className="ml-2">Pick UP</span>
            </label>

            <label>
              <input
                type="radio"
                name="delivery"
                value="delivery"
                checked={receivingPreference === "delivery"}
                onChange={handleReceivingPreferenceChange}
              />
              <span className="ml-2">Delivery</span>
            </label>
          </div>

          {/* Instructions Input Field */}

          {receivingPreference === "delivery" && (
            // <Delivery
            //   tipPercentage={tipPercentage}
            //   onTipPercentageChange={handleTipPercentageChange}
            // />
            <Delivery
              totalPrice={totalPrice} // Pass the total amount as a prop
              tipPercentage={tipPercentage}
              onTipPercentageChange={handleTipPercentageChange}
              // onCalculatedTipAmountChange={handleCalculatedTipAmountChange} // Pass the callback
              onCalculatedTipAmountChange={(value) => {
                setCalculatedTipAmount(value);
              }}
              onTipPercentageChange={(value) => {
                setTipPercentageChange(value);
              }}
            />
          )}
        </div>

        <div className=" flex justify-between">
          <span className="">Subtotal ({totalItems} items) </span>
          <span className="">${totalPrice}</span>
        </div>

        <div className=" flex justify-between">
          <span className="">Service Cost </span>
          <span className="">${serviceCost.toFixed(2)}</span>
          {/* <span className="">$0.00</span> */}
        </div>

        <div className=" flex justify-between">
          <span className="">Delivery Cost </span>
          <span className=" text-green-500">${deliveryCost.toFixed(2)}</span>
          {/* <span className=" text-green-500">FREE</span> */}
        </div>

        {(tipPercentage === "5%" ||
          tipPercentage === "10%" ||
          tipPercentage === "15%" ||
          tipPercentage === "20%") && (
          <div className=" flex justify-between">
            <span className="">Tips </span>
            <span className=" text-green-500">
              ${calculatedTipAmount.toFixed(2)}
            </span>
            {/* <span className=" text-green-500">${formattedTipAmount}</span> */}
            {/* <span className=" text-green-500">FREE</span> */}
          </div>
        )}

        <hr className=" my-2" />
        <div className=" flex justify-between">
          <span className="">Total(INC. TAX) </span>
          <span className=" font-bold">${totalCost.toFixed(2)}</span>
          {/* <span className=" font-bold">${totalPrice}</span> */}
        </div>
        <button
          className=" bg-red-500 text-white p-3 rounded-md w-1/2 self-end"
          onClick={handleCheckout}
        >
          CHECKOUT
        </button>
      </div>
    </div>
  );
};

export default CartPage;































<!-- {/* <div className="w-full flex  flex-col gap-2 ">
          <label className="text-sm">Category</label>
          <select
            name="catSlug"
            value={inputs.catSlug}
            onChange={handleChangeSlug}
            className="ring-1 ring-red-200 p-4 rounded-sm placeholder:text-red-200 outline-none"
          >
            {catList.map((item, index) => (
              <option key={index}>{item}</option>
            ))}
          </select>
          {/* Dropdown options  */}
        </div> */} -->

<div className="w-full flex flex-col gap-2">
  <label className="text-sm">Category</label>
  {catList.length > 0 ? (
  <select
    name="catSlug"
    value="{inputs.catSlug}"
    onChange="{handleChangeSlug}"
    className="ring-1 ring-red-200 p-4 rounded-sm placeholder:text-red-200 outline-none"
  >
    {catList.map((item, index) => (
    <option key="{index}">{item}</option>
    ))}
  </select>
  ) : (
  <div className="flex gap-2">
    <select
      name="catSlug"
      value="{inputs.catSlug}"
      onChange="{handleChangeSlug}"
      className="ring-1 ring-red-200 p-2 rounded-sm placeholder:text-red-200 outline-none"
    >
      <option value="" disabled hidden>Select or Add</option>
      {catList.map((item, index) => (
      <option key="{index}">{item}</option>
      ))}
    </select>
    <input
      type="text"
      name="newCatSlug"
      value="{inputs.catSlug}"
      onChange="{handleChangeSlug}"
      placeholder="New category..."
      className="ring-1 ring-red-200 p-2 rounded-sm placeholder:text-red-200 outline-none"
    />
  </div>
  )} {/* Dropdown options or input */}
</div>
